<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Book Review: Generic Data Structures and Algorithms in Go</title> <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "0550f3275b4a4db8bfeefed116695300"}'></script> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> </ul> </div> <div id=main > <div class=franklin-content > <h1 id=title ><a href="#title" class=header-anchor >Book Review: Generic Data Structures and Algorithms in Go</a></h1> <p> <div style="max-width: 250px"> <img src="/assets/images/bookcover-generic-ds-algo-in-go.jpeg" alt="" /> </div> </p> <p>I read this book last year, shortly after it&#39;s released on O&#39;Reilly. It&#39;s probably the worst Go book of 2022.</p> <h2 id=a_slow_hashtable ><a href="#a_slow_hashtable" class=header-anchor >A Slow HashTable?</a></h2> <p>Chapter 7 introduces a simple closed addressing<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup> hash table, and according to author&#39;s benchmark, it&#39;s <strong>3000x</strong> slower than Go&#39;s map<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>.</p> <pre><code class="shell hljs">Benchmark test begins to test words: 500000
Time to test all words in myTable: 1m17.880336666s
Time to test words in mapCollection: 24.405583ms</code></pre> <blockquote> <p>Quite a dramatic difference&#33; – Dr.Wiener </p> </blockquote> <p>How can you accept that you have implemented such a slow hash table without questioning the implementation and benchmark result?</p> <p>10x is okay since Go&#39;s map is highly optimized, but it&#39;s 3000x, there must be something wrong.</p> <p>Let&#39;s see if you can spot the problem from only the type definition:</p> <pre><code class="go hljs"><span class=hljs-keyword >const</span> tableSize = <span class=hljs-number >100_000</span>

<span class=hljs-keyword >type</span> HashTable [tableSize]WordType

<span class=hljs-keyword >type</span> WordType <span class=hljs-keyword >struct</span> {
        word <span class=hljs-type >string</span>
        list []<span class=hljs-type >string</span>
}

<span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-title >NewTable</span><span class=hljs-params >()</span></span> HashTable {}

<span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-params >(table *HashTable)</span></span> Insert(word <span class=hljs-type >string</span>) {}

<span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-params >(table HashTable)</span></span> IsPresent(word <span class=hljs-type >string</span>) <span class=hljs-type >bool</span> {}</code></pre> <p>Aha, <code>HashTable</code> is an array, and <code>IsPresent</code> takes a value receiver. So everytime you call <code>IsPresnet</code>, you make a copy of the array.</p> <p>I fixed it by simply adding a <code>*</code>, and here&#39;s the benchmark result:</p> <pre><code class="shell hljs">goos: linux
goarch: amd64
cpu: AMD Ryzen 7 5800H with Radeon Graphics
pkg: ...
BenchmarkHashTable-16                 40          25557889 ns/op               0 B/op          0 allocs/op
BenchmarkMap-16                       30          34354666 ns/op               0 B/op          0 allocs/op
PASS</code></pre> <p>In the author&#39;s test scenario, the simple hash table is actually faster than Go&#39;s map<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup>.</p> <p>The author is just not very rigorous about performance, and probably don&#39;t known enough Go :&#40;</p> <h2 id=concurrency ><a href="#concurrency" class=header-anchor >Concurrency?</a></h2> <p>Besides the introductory chapter, there are only 3 chapters that involve concurrency.</p> <p>In chapter 4, the book introduces Game of Life. </p> <p>It utilize <a href="https://fyne.io/">fyne</a> to display the grid, so it need to run the simulation in a goroutine. Fair use case but not related to data structure and algorithm.</p> <p>In chapter 10, it implement a &quot;concurrent&quot; AVL tree, bascailly a sharding map, not very interesting.</p> <p>In chapter 14, we get another simulation. This time we simulate three species in an ocean.</p> <p>Inside a 50x50 grid, we have agents that move concurrently according to some rules. Here&#39;s how they are implemented:</p> <pre><code class="go hljs"><span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-params >(shark *Shark)</span></span> Move() {
	<span class=hljs-keyword >for</span> ; quit == <span class=hljs-literal >false</span> ; {
		<span class=hljs-keyword >if</span> shark.x == <span class=hljs-number >-1</span> {
			<span class=hljs-keyword >break</span>
		}
		mutex.Lock()
		<span class=hljs-comment >// ... rules here </span>
		mutex.Unlock()
		time.Sleep(time.Duration(rand.Intn(<span class=hljs-number >500</span>) + <span class=hljs-number >500</span>) * time.Millisecond)
	}
}

<span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-params >(tuna *Tuna)</span></span> Move() {
	<span class=hljs-keyword >for</span> ; quit == <span class=hljs-literal >false</span> ; {
		mutex.Lock()
		<span class=hljs-comment >// ... rules here </span>
		mutex.Unlock()
		time.Sleep(time.Duration(rand.Intn(<span class=hljs-number >500</span>) + <span class=hljs-number >500</span>) * time.Millisecond)
	}
}

<span class=hljs-function ><span class=hljs-keyword >func</span> <span class=hljs-params >(mackerel *Mackerel)</span></span> Move() {
	<span class=hljs-keyword >for</span> ; quit == <span class=hljs-literal >false</span> ; {
		mutex.Lock()
		<span class=hljs-comment >// ... rules here </span>
		mutex.Unlock()
		time.Sleep(time.Duration(rand.Intn(<span class=hljs-number >500</span>) + <span class=hljs-number >500</span>) * time.Millisecond)
	}
}</code></pre> <p>So they all take the same mutex, and they can&#39;t run concurrency&#33; It&#39;s an useless case of goroutine.</p> <p>Not to mention the data race of the <code>quit</code> variable, it needs atomic loading.</p> <p>And if you run it with <code>-race</code>, you can see more data races, lol.</p> <p>I will simply select one agent randomly and update it, no concurrency, no locking, no data races.</p> <h2 id=waste_of_paper ><a href="#waste_of_paper" class=header-anchor >Waste of paper</a></h2> <p>Many code are duplicated, first in introduction, then in complete program.</p> <p>The last chapter include the training progress of a neural networks, 99 lines of <code>cost &#61; 0.XXXXX</code>. </p> <p>Thank God, the author replace some output with <code>...</code>, so we have only 99 lines.</p> <p>That&#39;s probably why this book take 590 pages.</p> <h2 id=generic ><a href="#generic" class=header-anchor >Generic?</a></h2> <p>This books actually don&#39;t include much generic code.</p> <p>For introducing generics, I would say most blog post on the internet did a better job than this book.</p> <h2 id=summary ><a href="#summary" class=header-anchor >Summary </a></h2> <p>It&#39;s probably the wrost Go book of 2022.</p> <p>Maybe you would say this is data structures and algorithms book, not a Go book, so some incorrect usage of Go is okay.</p> <p>But then why not grab a serious algorithm book?</p> <p>The only possible selling point of this book is Go, but it failed to achieve it.</p> <p>My rating: ★☆☆☆☆ &#40;1/5&#41;, Not Recommended.</p> <p><table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content >This book doesn&#39;t introduces the concept of open and closed addressing. </table> <table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >All benchmark code in this books simply use <code>time.Now</code> and <code>time.Since</code> to measure the time. </table> <table class=fndef  id="fndef:3"> <tr> <td class=fndef-backref ><a href="#fnref:3">[3]</a> <td class=fndef-content >I also did this benchmark on my Pentium T4500 machine, still no 10x slowness </table> </p> <pre><code class="shell hljs">cpu: Pentium(R) Dual-Core CPU       T4500  @ 2.30GHz
BenchmarkHashTable-2           7         147249004 ns/op               0 B/op          0 allocs/op
BenchmarkMap-2                12          97398657 ns/op               0 B/op          0 allocs/op</code></pre> <div class=page-foot > Kauruus <br> <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <br> Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script src="/libs/highlight/languages/lisp.min.js"></script> <script src="/libs/highlight/languages/julia.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>